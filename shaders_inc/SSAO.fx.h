"\n"
"#include \"FullScreenTriangleVSOutput.fxh\"\n"
"#include \"BasicStructures.fxh\"\n"
"\n"
"Texture2D<float>   g_tex2DDepthBuffer;\n"
"Texture2D<float4>  g_tex2DSrcColor;\n"
"\n"
"cbuffer cbCameraAttribs\n"
"{\n"
"    CameraAttribs g_CameraAttribs;\n"
"}\n"
"\n"
"float DepthToCameraZ(in float fDepth, in matrix mProj)\n"
"{\n"
"    // Transformations to/from normalized device coordinates are the\n"
"    // same in both APIs.\n"
"    // However, in GL, depth must be transformed to NDC Z first\n"
"\n"
"    float z = DepthToNormalizedDeviceZ(fDepth);\n"
"    return MATRIX_ELEMENT(mProj,3,2) / (z - MATRIX_ELEMENT(mProj,2,2));\n"
"}\n"
"\n"
"void ApplySSAO(FullScreenTriangleVSOutput VSOut,\n"
"               // IMPORTANT: non-system generated pixel shader input\n"
"               // arguments must have the exact same name as vertex shader \n"
"               // outputs and must go in the same order.\n"
"               // Moreover, even if the shader is not using the argument,\n"
"               // it still must be declared.\n"
"              out float4 f4Color : SV_Target)\n"
"{\n"
"    float fDepth = g_tex2DDepthBuffer.Load( int3(VSOut.f4PixelPos.xy,0) );\n"
"    float fCamSpaceZ = DepthToCameraZ(fDepth, g_CameraAttribs.mProj);\n"
"\n"
"    float Occlusion = 0.0;\n"
"    for(int i=-4; i <= +4; i+=2)\n"
"    {\n"
"        for(int j=-4; j <= +4; j+=2)\n"
"        {\n"
"            float fSampleDepth = g_tex2DDepthBuffer.Load( int3(VSOut.f4PixelPos.xy,0) + int3(i,j,0) );\n"
"            float fSampleCamSpaceZ = DepthToCameraZ(fSampleDepth, g_CameraAttribs.mProj);\n"
"            Occlusion += (fSampleCamSpaceZ > fCamSpaceZ - 1e-3) ? 1.0 : 0.0;\n"
"        }\n"
"    }\n"
"    Occlusion /= 25.f;\n"
"\n"
"    //fColor = NormalizedDeviceXYToTexUV(VSOut.f2NormalizedXY);\n"
"    f4Color = g_tex2DSrcColor.Load( int3(VSOut.f4PixelPos.xy,0) ) * Occlusion;\n"
"}\n"
